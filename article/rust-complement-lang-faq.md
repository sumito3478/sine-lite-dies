---
title: Rust言語FAQ和訳
tags: [ rust/doc ]
toc: true
---

<div class="rust-doc" lang="ja">

この文書は [Rust言語FAQ](https://doc.rust-lang.org/complement-lang-faq.html)の和訳です。

- この翻訳は試訳です。*既知の*誤訳、良くない訳、一貫性のない訳がまだ修正されていない部分があります。
- 原文は[5月15日時点のの stable ブランチのソースコード][english_source]を参照しています。

[english_source]: https://github.com/rust-lang/rust/blob/a59de37e99060162a2674e3ff45409ac73595c0e/src/doc/complement-lang-faq.md

## Rust で書かれた大きなプログラムはもうある？ 大きなサンプルコードが読みたい。

大きなプログラムはまだそう多くない。
Rustの[コンパイラ][rustc]は、このFAQを書いている時点で6万行以上の実装になるが、
Rust自身で書かれている。
Rustで書かれた最も古いコードとして、言語の紆余曲折を経験しているため、
良いコードと悪いコードが混在している。
学習には最適とは言えないかもしれないが、[borrowck]と[resolve]は
最近書かれている。

[rustc]: https://github.com/rust-lang/rust/tree/master/src/librustc
[resolve]: https://github.com/rust-lang/rust/blob/master/src/librustc/middle/resolve.rs
[borrowck]: https://github.com/rust-lang/rust/blob/master/src/librustc/middle/borrowck/

実験的ブラウザエンジンの [Servo][servo]は、現在たくさんのクレートにちらばった3万行以上の実装になる。
Servoを読むことはRustの特色ある型システム、並行機能、たくさんのネイティブライブラリの統合の練習になる。

[servo]: https://github.com/servo/servo

他には、言語のいろいろな面を説明するいくつかの例がある。

* [sprocketnes] は GC なしで実装された NES エミュレータで、Rustの新しい規約に則って書かれている。
* Rustの汎用 [hash] 関数である SipHash-2-4。 Bit 演算、オブジェクト指向、マクロの例になる。
* 標準ライブラリの [HashMap]。オブジェクト指向のスタイルで書かれた Sendable なハッシュマップの例。
* 標準ライブラリの [json] モジュール。列挙型とパターンマッチングの例。

[sprocketnes]: https://github.com/pcwalton/sprocketnes
[hash]: https://github.com/rust-lang/rust/blob/master/src/libstd/hash/mod.rs
[HashMap]: https://github.com/rust-lang/rust/blob/master/src/libcollections/hashmap.rs
[json]: https://github.com/rust-lang/rust/blob/master/src/libserialize/json.rs

GitHubで[トレンド入りした Rust レポジトリ][github-rust]を見るのも良いだろう。

[github-rust]: https://github.com/trending?l=rust

## Rust をプロダクション環境で使っている人がいる？

Rustはまだ 1.0 がリリースされていない。そのため、よく分からずに Rust をプロダクション環境で使うことは
おすすめできない。

とはいえ、 Rust をプロダクション環境で使っている例が 2 つ知られている。

* [OpenDNS](http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/)
* [Skylight](http://skylight.io)

例が数えるほどしかないことをもって警告としよう。

## Rust は Windows で動く？

動く。開発は 3 つのターゲットプラットフォーム全てで歩調を合わせて行われている（WindowsではMinGWを使う。Cygwinではない）。

## Rust はオブジェクト指向言語？ オブジェクト指向言語でするようなことをどうすればRustでできる？

Rustはマルチパラダム言語だ。全てのことをひとつの抽象化に押し込めることはない。
オブジェクト指向言語で行われるようなことの多くはRustでもできるが、全てではない。
書き手のプログラマが慣れている抽象化だけを常に使うということはない。

## Null ポインタなしでどうやって済ませるの。

Rust におけるデータ値は限られた種類の初期化形式のみで構築される。それぞれの初期化形式は入力が既に初期化されていることを要求する。
生存解析により、ローカル変数が使用される前に初期化されていることが確かめられる。

## モジュールとクレートの関係は？

* クレートはトップレベルのコンパイル単位で、ロード可能な単一のオブジェクトに対応する。
* モジュールはクレート内部の（ネストしうる）名前管理の単位だ。
* クレートは暗黙の、無名のトップレベルモジュールを持つ。
* 再帰的定義は複数のモジュールをまたがることはできるが、複数のクレートをまたがることはできない。
* クレートはグローバル名を持たない。重複のありえるメタデータタグだけを持つ。
* クレートをまたがるグローバルな名前空間はない。全ての名前管理はクレートの中で行われる。
 * クレートが他のクレートを使うと、使われるクレートの最上位の名前空間が使う側の名前空間にバインドされる。

## なぜpanicによる巻き戻しを同一スレッドで回復できない？どうして「例外をキャッチ」しようとしない？

catch ブロックの動的環境や、巻き戻されるヒープに保持されている不変オブジェクトについて保証できることが少なすぎ、安全に再開することができない。
エラーの伝達やロギングには他の方法がより適切だと考えている。すなわち、別々のヒープ間を「強固に」分離するという役割を果たすスレッドを使う方法だ。

Rust は、「例外をキャッチ」するロジックの 3 つの主要なロジックの組み合わせを処理する 3 つの判定とよく定義されたオプションを提供する。

* 失敗の _ロギング_ は統合されたロギングシステムによって行われる。
* panicの後の _回復_ はスレッドのパニックをスレッドの _外側_ からトラップすることで行われる。
  他のスレッドはpanicの悪影響を受けていないからだ。
* リソースの _クリーン_ はデストラクタを持つ RAII スタイルのオブジェクトによって行われる。

RAII スタイルのデストラクタを通じたクリーンはいずれにせよ catch ブロックよりも有効に働くはずだ。
というのも catch ブロックより良くテストされるからだ（エラーでない制御パスの一部であるから、常に実行される）。

## モジュールに型パラメータをつけられないのはなぜ？

実行時にパラメータを与えることができるようにしたい。
この制限は結局は変えるかもしれないが、初期段階の今ではこのような型パラメータの実装になっている。


## どうして値に型パラメータをつけられないのか？どうしてアイテムだけなのか？

値に型パラメータをつけられるようにすると型推論が複雑になり、実行時パラメータ化の実装戦略も工夫する必要がある。

## どうして列挙型は名前型で閉じているのか？

明らかで、簡単で、効率的で、教科書通りの、開いていたり構造型である直和型の実装方法を知らないからだ。
明白かつよく探求された意味論をもつ言語機能にとどまりたい。

## どうしてチャネルが同期的でないの？

この話題については多くの議論がある。
「デフォルトで同期」・「デフォルトで非同期」コミュニケーションという提案はよくある。
そしてどちらにも良い理由がある。
Rustの選択は以下の主張に基づく。

* スレッドの隔離のポイントにはあるスレッドをもうひとつのスレッドから切り離すということがある。
  これはひとつのスレッドがもうひとつのスレッドに過度の制約（あるいはバグ！）を課さないことを前提にするという方法で実現される。
  一時的な結びつけは他の種類の方法とおなじぐらい本物だ。すなわち、「デフォルトで非同期」にすることによって、デフォルトの場合の制約を _時々_ スレッドを結びつけるだけに緩和できる。
* 「デフォルトで非同期」はコミュニケーションのバッファリングとバッチングをサポートする。
  それによってスレッドの切り替えとスレッド間・ドメイン間の同期の頻度と厳格さを減らすことができる。
* 「デフォルトで非同期」な送信可能チャネルは、より複雑な形態と戦略を組み立てるための最低レベルの構成単位になる。
  多くのユースケースが、多方面や多段階のより複雑なシナリオではなく、2方面のフル同期のパターンにそぐうのかどうか明らかでない。
  全てのプログラムに後者の前提を全てのコミュニケーションに縛り付けさせたくなかった。

## どうしてチャネルは二重化されていない（一方通信）なのか？

デフォルトで同期的なのと似たような理由だ。一方通信にすることによって、実装についての前提がより少なくて済む。
一方通信でも必要な前提は、より複雑なコミュニケーション形態が要求される場合を含めて、全てのユースケースで必要とされるものだ。


## どうして文字列がデフォルトでUTF-8なのですか？どうして UCS2 や UCS4 でないのか？

`str`型がUTF-8なのは実際の世界で多くのテキストがUTF-8で存在しているのをみているからだ。特にネットワーク通信でだ。エンディアンが任意だからだ。
そしてデフォルトの入出力が入力・出力のどちらの方向でもコードポイントを再コードせずに済むのが最良と考えているからだ。


文字列がUTF-8であることは、`str`の中のUnicodeコードポイントにインデックスでアクセスするのが、計算量がO(n)の操作になることを意味している。
これは明らかに望ましくない。
一方で、この問題はトレードオフの宝庫で、

* ASCII範囲のコードポイントのために`str`をスキャンする場合、なおも安全にオクテット単位の操作を行える。
  `.as_bytes()`を使えば、`u8`を取り出すのに必要なコストはO(1)だけであり、対応するASCII範囲の`char`にキャストしたり、比較したりできる値が返る。
  そのため、（たとえば）`'\n`で改行するのは、オクテット単位の扱いでなおも機能する。
  UTF-8はそういう扱いができるようによく設計されている。
* テキストにおけるほとんどの「文字志向」の操作は「ASCII範囲のコードポイントのみ」という非常に制限された言語の前提のもとで行われる。
  ASCII範囲外では、どちらにせよ、言語的単位（グリフ、単語、段落）の境界を見つけ出すために複雑な（定数時間で実行できない）アルゴリズムを使う傾向にある。
  「純正」の、言語学的なものを考慮した、Unicodeに採択されたアルゴリズムを使うことを勧める。
* `char`型はUCS4である。本当にコードポイントごとのアルゴリズムを使いたいなら、`type wstr = [char]`と書き、`str`をそのwstrに1パスで変換し、`wstr`上で操作することは簡単だ。
  言い換えれば、言語が「デフォルトでUCS4に変換しない」ことは、プログラマが必要ならデコード（あるいはエンコードしなおす）ことを妨げない。

## どうして（たとえば）特殊なトレイトやその実装のかわりに、文字列やベクターなどの組み込み型が用意されているの？

どの場合も、オペレータ、リテラルコンストラクタ、オーバーロードされた使用、組み込みの制御構造との統合などのうちのどれかがあって、
それを使うことによって、より汎用的な型コンストラクタでその型を表現することが無骨と思わせるようなケースがある。
たとえば、数値がそうであるのと同じだ！とはいえこれには美学的な部分もある。
このような特殊なケースをなくしたり置き換えるうまい提案があれば見てみる。

## Rust のコードから C のコードを呼べる？

呼べる。C のコードを Rust から呼ぶのは単純で、C から C のコードを呼ぶのと同じぐらい効率的だ。

## C のコードから Rust のコードを呼べる？

呼べる。Rust のコードは `extern` 宣言で公開されている必要がある。`extern` 宣言によって Rust のコードは C-ABI 互換になる。
そうした関数は C のコードに関数ポインタとして渡せるし、`#[no_mangle]` 属性をつけてシンボルのマングリングをオフにすれば、 C のコードから直接呼ぶことができる。

## どうして関数のシグネチャが推論されない？どうしてローカルスロットだけ推論されるのか？

* コンパイラとしては、推論のアルゴリズムが単純になるからだ。推論は1つの関数を一度だけ見れば良くなる。
* その単純化は人間の読者にも当てはまる。読者は関数の引数の型を推測するのに、IDEに推論アルゴリズムをクレート全体に渡って走らせる必要がなくなる。引数の型は常に明示的ですぐそこに記述されているのだ。

## トレイトのメソッドを呼ぶのにどうして明示的な境界の指定が必要なのか？C++のテンプレートでは必要ないのに？

* 明示的な境界指定を要求することによって、コンパイラは型パラメータのついたアイテムが*定義*されるときに型チェックすることができる。でなければ型パラメータがインスタンス化されるときまで型チェックが遅延しないといけない。
* APIに境界指定のリストがあれば、それを満たす*任意の*型パラメータでコンパイルが通ることが分かる。境界指定は強制される最低限のドキュメンテーションであり、またエラーメッセージがとても読みやすくなる。

* メソッドのスコープもまた問題になる。C++は[ADL](https://ja.wikipedia.org/wiki/%E5%AE%9F%E5%BC%95%E6%95%B0%E4%BE%9D%E5%AD%98%E3%81%AE%E5%90%8D%E5%89%8D%E6%8E%A2%E7%B4%A2)を必要するが、
  ADLには問題が多い。明示的な境界指定でこの問題を回避できる。トレイトは明示的にインポートされ型パラメータの境界指定で使われるから、
  トレイトのメソッドから実装への明確なマッピングが存在する（トレイトとインスタンス化された型を通じて）。

  * 上記の点に関連して：パラメータが明確にトレイトの境界の名をあげるので、メソッドの名前がかぶる複数のトレイトをひとつの型がきれいに曖昧さなく実装できる。

* より深い議論は、[Rustメーリングリストのこのスレッド](https://mail.mozilla.org/pipermail/rust-dev/2013-September/005603.html)にある。

## Rust はセミコロンの自動挿入を実装することになるだろうか。Go言語のように。

言語を単純にするため、実装しないつもりだ。Rust にセミコロンの自動挿入を実装するのはややこしい。セミコロンがないことが「値を返す」ことを意味するからだ。

## 自分のプログラムにログマクロの出力を表示させるにはどうすれば良い？

**簡単に言えば**: `RUST_LOG` 環境変数をソースファイルの名前に設定する。ただし拡張子はなし。

```sh
rustc hello.rs
export RUST_LOG=hello
./hello
```

**もっと詳しく**: `RUST_LOG`はコンマで区切られたパスのリストで構成された「ロギング仕様」をとる。
パスはダブルコロンで区切られた1つのクレートの名前と複数のモジュールの名前の列で構成される。
スタンドアロンの `.rs` ファイルの場合、クレートは暗黙にソースファイルに名前に基づいて名前が決まるから、
上の例では `RUST_LOG` を hello クレートの名前に設定している。
複数のパスを組み合わせることで必要なロギングを実現できる。
たとえば、コンパイラのリンクをデバッグするときは、以下のように設定できるだろう。

```sh
RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath
```

完全な説明については、[the logging crate][1] を見てもらいたい。

## Rust はどのぐらい速い？

この手の質問は常に答えにくい。速度のために改良すべき点はまだ多い。
何をベンチマークするかによって、Rustはいろいろなパフォーマンスを示す。

とはいえ、 Rust には多くの状況で C++ に匹敵する速度を出すという明確な目標がある。
言語機能をどのようにするかという決定は性能を念頭に置いてなされる。
そして Rust をできるだけ速くしようとしている。
また、Rust は LLVM の上に実装されているから、LLVM におけるあらゆる性能改善は Rust の高速化を助ける。

[1]:log/index.html

</div>
